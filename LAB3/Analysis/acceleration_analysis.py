# -*- coding: utf-8 -*-
"""Acceleration_analysis.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1NtV8CZyDljWleFabjspG9YcZBv0fh7v9
"""

!pip install bagpy
!pip install allantools
from IPython.display import clear_output
clear_output()

import bagpy
from bagpy import bagreader
import pandas as pd
import seaborn as sea
import matplotlib.pyplot as plt
from mpl_toolkits import mplot3d
import numpy as np
import sys
from scipy import stats
import allantools
import allantools
import math

imu_bag = bagreader("LocationC.bag")
imu_free = imu_bag.message_by_topic('/vectornav')

df_imu_free = pd.read_csv("LocationC/vectornav.csv",sep=',')

df_imu_free
print(df_imu_free.keys())

LocationD_x = []
LocationD_y = []
LocationD_z = []

time = []
for i in df_imu_free['data']:
    if len(str(i).split(",")) >= 13:
        LocationD_x.append(float(str(i).split(",")[7])) 
        LocationD_y.append(float(str(i).split(",")[8]))
        LocationD_z.append(float(str(i).split(",")[9]))
        
        
for i in df_imu_free["header.stamp.secs"][1:]:
    time.append(i-df_imu_free["header.stamp.secs"][0])

df_imu_free['data'][0]

fig, ax = plt.subplots(figsize=(10,5))

r = 40
(t2, ad, ade, adn) = allantools.adev(np.array(LocationD_x), rate=r, data_type="freq", taus="decade")
(t22, add, adde, addn) = allantools.adev(np.array(LocationD_y), rate=r, data_type="freq", taus="decade")
(t222, addd, addde, adddn) = allantools.adev(np.array(LocationD_z), rate=r, data_type="freq", taus="decade")
fig = plt.loglog(t2, ad,label = "Gyro_x") # Plot the results
fig = plt.loglog(t22, add,label = "Gyro_y")
fig = plt.loglog(t222, addd,label = "Gyro_z")
plt.xscale("log")
plt.yscale("log")
plt.xlabel(r'$\tau$')
plt.ylabel(r'$\sigma(\tau)$')
plt.title("Allan Deviation (Accel)")
plt.grid(True)
plt.legend()
plt.show()

fig
slope = -0.5
logtau = np.log10(t2)
logadev = np.log10(ad)
dlogadev = np.diff(logadev) / np.diff(logtau)
i= np.argmin(abs(dlogadev - slope))

b = logadev[i] - slope*logtau[i]

logN = slope*np.log(1) + b
N = 10**logN
print("Angle Random walk(N) of x_axis = " + str(N))

tauN = 1;
lineN = N / np.sqrt(t2);
fig=  plt.loglog(t2, ad,label = r'$\sigma_x$')
fig=  plt.loglog(t2, lineN, '--',label = r'$\sigma_{N,x}$')
fig=  plt.loglog(tauN, N, 'o',label = r"$N_x$")

slope = -0.5
logtau = np.log10(t22)
logadev = np.log10(add)
dlogadev = np.diff(logadev) / np.diff(logtau)
i= np.argmin(abs(dlogadev - slope))

b = logadev[i] - slope*logtau[i]

logN = slope*np.log(1) + b
N = 10**logN
print("Angle Random walk(N) of y_axis = " + str(N))

tauN = 1;
lineN = N / np.sqrt(t22);
fig=  plt.loglog(t22, add,label = r'$\sigma_y$')
fig=  plt.loglog(t22, lineN, '--',label = r'$\sigma_{N,y}$')
fig=  plt.loglog(tauN, N, 'o',label = r"$N_y$")

slope = -0.5
logtau = np.log10(t222)
logadev = np.log10(addd)
dlogadev = np.diff(logadev) / np.diff(logtau)
i= np.argmin(abs(dlogadev - slope))

b = logadev[i] - slope*logtau[i]

logN = slope*np.log(1) + b
N = 10**logN
print("Angle Random walk(N) of z_axis = " + str(N))

tauN = 1;
lineN = N / np.sqrt(t22);
fig=  plt.loglog(t222, addd,label = r'$\sigma_z$')
fig=  plt.loglog(t222, lineN, '--',label = r'$\sigma_{N,z}$')
fig=  plt.loglog(tauN, N, 'o',label = r"$N_z$")

plt.xscale("log")
plt.yscale("log")
plt.xlabel(r'$\tau$')
plt.ylabel(r'$\sigma(\tau)$')
plt.title("Allan Deviation with Angle random walk (Accel)")
plt.grid(True, which = "both")
plt.legend()
plt.show()

slope = 0.5
logtau = np.log10(t2)
logadev = np.log10(ad)
dlogadev = np.diff(logadev) / np.diff(logtau)
i= np.argmin(abs(dlogadev - slope))

b = logadev[i] - slope*logtau[i]

logK = slope*np.log10(3) + b
K = 10**logK

print("Rate Random walk(K) of x_axis = " + str(K))

tauK = 3;
linek = K * np.sqrt(t2/3);
fig=  plt.loglog(t2, ad,label = r'$\sigma_x$')
fig=  plt.loglog(t2, linek, '--',label = r'$\sigma_{K,x}$')
fig=  plt.loglog(tauK, K, 'o',label = r"$K_x$")

slope = 0.5
logtau = np.log10(t22)
logadev = np.log10(add)
dlogadev = np.diff(logadev) / np.diff(logtau)
i= np.argmin(abs(dlogadev - slope))

b = logadev[i] - slope*logtau[i]

logK = slope*np.log10(3) + b
K = 10**logK

print("Rate Random walk(K) of y_axis = " + str(K))

tauK = 3;
linek = K * np.sqrt(t22/3);
fig=  plt.loglog(t22, add,label = r'$\sigma_y$')
fig=  plt.loglog(t22, linek, '--',label = r'$\sigma_{K,y}$')
fig=  plt.loglog(tauK, K, 'o',label = r"$K_y$")

slope = 0.5
logtau = np.log10(t222)
logadev = np.log10(addd)
dlogadev = np.diff(logadev) / np.diff(logtau)
i= np.argmin(abs(dlogadev - slope))

b = logadev[i] - slope*logtau[i]

logK = slope*np.log10(3) + b
K = 10**logK

print("Rate Random walk(K) of z_axis = " + str(K))

tauK = 3;
linek = K * np.sqrt(t222/3);
fig=  plt.loglog(t222, addd,label = r'$\sigma_z$')
fig=  plt.loglog(t222, linek, '--',label = r'$\sigma_{K,z}$')
fig=  plt.loglog(tauK, K, 'o',label = r"$K_z$")

plt.xscale("log")
plt.yscale("log")
plt.xlabel(r'$\tau$')
plt.ylabel(r'$\sigma(\tau)$')
plt.title("Allan Deviation with Rate random walk (Accel)")
plt.grid(True, which = "both")
plt.legend()
plt.show()

slope = 0
logtau = np.log10(t2)
logadev = np.log10(ad)
dlogadev = np.diff(logadev) / np.diff(logtau)
i= np.argmin(abs(dlogadev - slope))

b = logadev[i] - slope*logtau[i]

scfB = math.sqrt(2*np.log(2)/np.pi)
logB = b - np.log10(scfB)
B = 10**logB

print("Bias Instability(B) of x_axis = " + str(B))

tauB = t2[i];
lineB = B * scfB*np.ones(np.size(t2));
fig=  plt.loglog(t2, ad,label = r'$\sigma_x$')
fig=  plt.loglog(t2, lineB, '--',label = r'$\sigma_{B,x}$')
fig=  plt.loglog(tauB, scfB*B, 'o',label = r"$B_x$")

slope = 0
logtau = np.log10(t22)
logadev = np.log10(add)
dlogadev = np.diff(logadev) / np.diff(logtau)
i= np.argmin(abs(dlogadev - slope))

b = logadev[i] - slope*logtau[i]

scfB = math.sqrt(2*np.log(2)/np.pi)
logB = b - np.log10(scfB)
B = 10**logB

print("Bias Instability(B) of y_axis = " + str(B))

tauB = t22[i];
lineB = B * scfB*np.ones(np.size(t22));
fig=  plt.loglog(t22, add,label = r'$\sigma_y$')
fig=  plt.loglog(t22, lineB, '--',label = r'$\sigma_{B,y}$')
fig=  plt.loglog(tauB, scfB*B, 'o',label = r"$B_y$")

slope = 0
logtau = np.log10(t222)
logadev = np.log10(addd)
dlogadev = np.diff(logadev) / np.diff(logtau)
i= np.argmin(abs(dlogadev - slope))

b = logadev[i] - slope*logtau[i]

scfB = math.sqrt(2*np.log(2)/np.pi)
logB = b - np.log10(scfB)
B = 10**logB

print("Bias Instability(B) of z_axis = " + str(B))

tauB = t222[i];
lineB = B * scfB*np.ones(np.size(t222));
fig=  plt.loglog(t222, addd,label = r'$\sigma_z$')
fig=  plt.loglog(t222, lineB, '--',label = r'$\sigma_{B,z}$')
fig=  plt.loglog(tauB, scfB*B, 'o',label = r"$B_z$")

plt.xscale("log")
plt.yscale("log")
plt.xlabel(r'$\tau$')
plt.ylabel(r'$\sigma(\tau)$')
plt.title("Allan Deviation with Bias Instability (Accel)")
plt.grid(True, which = "both")
plt.legend()
plt.show()

len(time)

fig, ax = plt.subplots()
plt.plot(time[:719860],LocationD_x,label = "Gyro_x")
plt.plot(time[:719860],LocationD_y,label = "Gyro_y")
plt.plot(time[:719860],LocationD_z,label = "Gyro_z")
plt.xlabel('Time(sec)')
plt.ylabel('Raw Sensor data')
plt.title("Accel vs Time")
plt.legend()
plt.show()